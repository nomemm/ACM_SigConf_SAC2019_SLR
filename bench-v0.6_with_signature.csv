,fname,doc,repository
79D9B4DB619F85EB,"	SIMD_FORCE_INLINE void internalApplyImpulse(const btVector3& linearComponent, const btVector3& angularComponent, const btScalar impulseMagnitude)
	","Optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position",bullet3
C74CEE60AF732A54,"	SIMD_FORCE_INLINE btVector3& operator*=(const btVector3& v)
	","@brief Elementwise multiply this vector by the other 
 @param v The other vector ",bullet3
4B732A7D4583F1B9,"	B3_FORCE_INLINE const b3Vector3& operator[](int i) const
	","@brief Get a const reference to a row of the matrix as a vector 
@param i Row number 0 indexed ",bullet3
CF0FB37FEFB6B1E9,"	SIMD_FORCE_INLINE btVector3& operator/=(const btScalar& s)
	","@brief Inversely scale the vector 
 @param s Scale factor to divide by ",bullet3
0C3929BA6041DA4C,"	virtual btBroadphasePair* addOverlappingPair(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1)
	","Add a pair and return the new pair. If the pair already exists,
no new pair is created and the old one is returned.",bullet3
8F2E01C42FED29A6,"	B3_FORCE_INLINE void clear()
	","clear the array, deallocated memory. Generally it is better to use array.resize(0), to reduce performance overhead of run-time memory (de)allocations.",bullet3
66E0B8EAE18BD73F,"	btQuaternion& operator/=(const btScalar& s)
	","@brief Inversely scale this quaternion
 @param s The scale factor ",bullet3
79C981CD07A529F7,"	void setIdentity()
	",@brief Set the matrix to the identity ,bullet3
DC2BD5D0EA380700,"	btScalar dot(const btQuaternion& q) const
	","@brief Return the dot product between this quaternion and another
 @param q The other quaternion ",bullet3
D6632F6A4CB0E08B,"	void setRotation(const btQuaternion& q)
	","@brief Set the matrix from a quaternion
@param q The Quaternion to match ",bullet3
79D5D5A1A2CF7D89,"SIMD_FORCE_INLINE btQuaternion
operator*(const btQuaternion& q1, const btQuaternion& q2)
",@brief Return the product of two quaternions ,bullet3
8490AC97765F1D6C,"	btQuaternion getRotation() const
	",@brief Return a quaternion representing the rotation ,bullet3
644AC9DDE70BF687,"	btQuaternion& operator*=(const btQuaternion& q)
	","@brief Multiply this quaternion by q on the right
 @param q The other quaternion 
 Equivilant to this = this * q ",bullet3
6DB4903CDE3D2E8D,"SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::inverse() const
",@brief Return the inverse of the matrix ,bullet3
4D92A5C8ECB7C8E0,"	SIMD_FORCE_INLINE btScalar safeNorm() const
	",@brief Return the norm (length) of the vector ,bullet3
8525E9B5122076A1,"SIMD_FORCE_INLINE btMatrix3x3
btMatrix3x3::absolute() const
",@brief Return the matrix with all values non negative ,bullet3
B5A502EC16994350,"	void setRotation(const btVector3& axis, const btScalar& _angle)
	","@brief Set the rotation using axis angle notation 
 @param axis The axis around which to rotate
 @param angle The magnitude of the rotation in Radians ",bullet3
2E7884C495DBA639,"	btTransform inverse() const
	",@brief Return the inverse of this transform ,bullet3
CCEAF9ED3AB777D3,"	static const btTransform& getIdentity()
	",@brief Return an identity transform ,bullet3
E3447F956B0DAA2A,"SIMD_FORCE_INLINE bool operator==(const btTransform& t1, const btTransform& t2)
",@brief Test if two transforms have all elements equal ,bullet3
638333B760678A25,"SIMD_FORCE_INLINE bool operator==(const btMatrix3x3& m1, const btMatrix3x3& m2)
","@brief Equality operator between two matrices
It will test all elements are equal.  ",bullet3
D19B260C1600B5B7,"	void setEulerZYX(const b3Scalar& yawZ, const b3Scalar& pitchY, const b3Scalar& rollX)
	","@brief Set the quaternion using euler angles 
 @param yaw Angle around Z
 @param pitch Angle around Y
 @param roll Angle around X ",bullet3
1431A734ED055FA8,"static char *conf_get_string(const CONF *src_conf, const char *groups,
                             const char *name)
",get str value for name from a comma-separated hierarchy of config sections ,openssl
368707342DE88F61,"size_t construct_key_exchange_tbs(SSL_CONNECTION *s, unsigned char **ptbs,
                                  const void *param, size_t paramlen)
",Create a buffer containing data to be signed for server key exchange ,openssl
48267A0CCC9D9802,"int CRYPTO_ocb128_copy_ctx(OCB128_CONTEXT *dest, OCB128_CONTEXT *src,
                           void *keyenc, void *keydec)
","
 Copy an OCB128_CONTEXT object
 ",openssl
642B21019158955A,"static int addr_expand(unsigned char *addr,
                       const ASN1_BIT_STRING *bs,
                       const int length, const unsigned char fill)
","
 Expand the bitstring form of an address into a raw byte array.
 At the moment this is coded for simplicity, not speed.
 ",openssl
AE5043CE422C1C05,"static int IPAddressFamily_cmp(const IPAddressFamily *const *a_,
                               const IPAddressFamily *const *b_)
","
 Sort comparison function for a sequence of IPAddressFamily.

 The last paragraph of RFC 3779 2.2.3.3 is slightly ambiguous about
 the ordering: I can read it as meaning that IPv6 without a SAFI
 comes before IPv4 with a SAFI, which seems pretty weird.  The
 examples in appendix B suggest that the author intended the
 null-SAFI rule to apply only within a single AFI, which is what I
 would have expected and is what the following code implements.
 ",openssl
CD1542D0AEAA744A,"static int check_suffix(const char *str, const char *suffix)
","
 Check if |str| ends with |suffix| preceded by a space, and if it does,
 return the index of that space.  If there is no such suffix in |str|,
 return -1.
 For |str| == ""FOO BAR"" and |suffix| == ""BAR"", the returned value is 3.
 ",openssl
0EE32A0A9C311AAB,"static int check_end(const char *str, const char *end)
",Check if the end of a string matches 'end' ,openssl
620F31E815219213,"void ossl_quic_channel_set_msg_callback(QUIC_CHANNEL *ch,
                                        ossl_msg_cb msg_callback,
                                        SSL *msg_callback_ssl)
",Setters for the msg_callback and msg_callback_arg ,openssl
755C43F5B3FA4575,"QUIC_PORT *ossl_quic_engine_create_port(QUIC_ENGINE *qeng,
                                        const QUIC_PORT_ARGS *args)
","
 Create a port which is a child of the engine. args->engine shall be NULL.
 ",openssl
13E685EDA19828BF,"static int has_usable_cert(SSL_CONNECTION *s, const SIGALG_LOOKUP *sig, int idx)
","
 Returns true if |s| has a usable certificate configured for use
 with signature scheme |sig|.
 ""Usable"" includes a check for presence as well as applying
 the signature_algorithm_cert restrictions sent by the peer (if any).
 Returns false if no usable certificate is found.
 ",openssl
76AA2B71A9EFE21D,"int tls13_generate_handshake_secret(SSL_CONNECTION *s,
                                    const unsigned char *insecret,
                                    size_t insecretlen)
","
 Given an input secret |insecret| of length |insecretlen| generate the
 handshake secret. This requires the early secret to already have been
 generated. Returns 1 on success  0 on failure.
 ",openssl
F51460EBEA5EC73A,"int SSL_export_keying_material_early(SSL *s, unsigned char *out, size_t olen,
                                     const char *label, size_t llen,
                                     const unsigned char *context,
                                     size_t contextlen)
","
 SSL_export_keying_material_early exports a value derived from the
 early exporter master secret, as specified in
 https://tools.ietf.org/html/draft-ietf-tls-tls13-23. It writes
 |olen| bytes to |out| given a label and optional context. It
 returns 1 on success and 0 otherwise.
 ",openssl
95D36DAC386C30F9,"int ossl_provider_up_ref_parent(OSSL_PROVIDER *prov, int activate)
","
 ossl_provider_up_ref_parent() and ossl_provider_free_parent() do
 nothing in ""self-referencing"" child providers, i.e. when the parent
 of the child provider is the same as the provider where this child
 provider was created.
 This allows the teardown function in the parent provider to be called
 at the correct moment.
 For child providers in other providers, the reference count is done to
 ensure that cross referencing is recorded.  These should be cleared up
 through that providers teardown, as part of freeing its child libctx.
 ",openssl
77A8F931A0C1CD5C,"void ossl_ctx_global_properties_free(void *vglobp)
",Global properties are stored per library context ,openssl
3428FE5AC8D7F9FA,"const char *evp_keymgmt_util_query_operation_name(EVP_KEYMGMT *keymgmt,
                                                  int op_id)
","
 If |keymgmt| has the method function |query_operation_name|, use it to get
 the name of a supported operation identity.  Otherwise, return the keytype,
 assuming that it works as a default operation name.
 ",openssl
D6EC6B1ACE221810,"static int match_type(const EVP_KEYMGMT *keymgmt1, const EVP_KEYMGMT *keymgmt2)
","
 match_type() checks if two EVP_KEYMGMT are matching key types.  This
 function assumes that the caller has made all the necessary NULL checks.
 ",openssl
A15E1111AA115EBE,"int ossl_rsa_sp800_56b_validate_strength(int nbits, int strength)
","
 Validates the RSA key size based on the target strength.
 See SP800-56Br1 6.3.1.1 (Steps 1a-1b)

 Params:
     nbits The key size in bits.
     strength The target strength in bits. -1 means the target
              strength is unknown.
 Returns: 1 if the key size matches the target strength, or 0 otherwise.
 ",openssl
2EC2B72D1CCAE2A5,"static EVP_PKEY *evp_pkey_keygen(OSSL_LIB_CTX *libctx, const char *name,
                                 const char *propq, const OSSL_PARAM *params)
","
 evp_pkey_keygen() abstracts from the explicit use of B<EVP_PKEY_CTX>
 while providing a generic way of generating a new asymmetric key pair
 of algorithm type I<name> (e.g., C<RSA> or C<EC>).
 The library context I<libctx> and property query I<propq>
 are used when fetching algorithms from providers.
 The I<params> specify algorithm-specific parameters
 such as the RSA modulus size or the name of an EC curve.
 ",openssl
08A6FA08CFC72ED6,"int OSSL_STORE_eof(OSSL_STORE_CTX *ctx)
","
 Check if end of data (end of file) is reached
 Returns 1 on end, 0 otherwise.
 ",openssl
6563624997F5DB4A,"int X509_self_signed(X509 *cert, int verify_signature)
","-
 Return 1 if given cert is considered self-signed, 0 if not, or -1 on error.
 This actually verifies self-signedness only if requested.
 It calls ossl_x509v3_cache_extensions()
 to match issuer and subject names (i.e., the cert being self-issued) and any
 present authority key identifier to match the subject key identifier, etc.",openssl
AC4F3EF59CA94B57,"static int check_issued(ossl_unused X509_STORE_CTX *ctx, X509 *x, X509 *issuer)
",Check that the given certificate |x| is issued by the certificate |issuer| ,openssl
9566C87BE346F08A,"void ossl_quic_channel_free(QUIC_CHANNEL *ch)
",No-op if ch is NULL. ,openssl
F0718158305A9415,"static void free_rcu_thr_data(void *ptr)
","
 Called on thread exit to free the pthread key
 associated with this thread, if any
 ",openssl
FBE031EE3DC1FDB6,"static int provider_conf_params(OSSL_PROVIDER *prov,
                                OSSL_PROVIDER_INFO *provinfo,
                                const char *name, const char *value,
                                const CONF *cnf)
","
 recursively parse the provider configuration section
 of the config file. 
 Returns
 1 on success
 0 on non-fatal error
 < 0 on fatal errors
 ",openssl
C8EF3908D2059468,"int ossl_quic_tx_packetiser_set_initial_token(OSSL_QUIC_TX_PACKETISER *txp,
                                              const unsigned char *token,
                                              size_t token_len,
                                              ossl_quic_initial_token_free_fn *free_cb,
                                              void *free_cb_arg)
","
 Set the token used in Initial packets. The callback is called when the buffer
 is no longer needed; for example, when the TXP is freed or when this function
 is called again with a new buffer. Fails returning 0 if the token is too big
 to ever be reasonably encapsulated in an outgoing packet based on our current
 understanding of our PMTU.
 ",openssl
5659C3E7C6372047,"int evp_pkey_decrypt_alloc(EVP_PKEY_CTX *ctx, unsigned char **outp,
                           size_t *outlenp, size_t expected_outlen,
                           const unsigned char *in, size_t inlen)
","decrypt to new buffer of dynamic size, checking any pre-determined size ",openssl
148903C6EE544163,"int tls1_set_peer_legacy_sigalg(SSL_CONNECTION *s, const EVP_PKEY *pkey)
",Set peer sigalg based key type ,openssl
1544A5B6387D628A,"void ossl_qrx_pkt_release(OSSL_QRX_PKT *pkt)
","
 Decrement the reference count for the given packet and frees it if the
 reference count drops to zero. No-op if pkt is NULL.
 ",openssl
29F9962F61ED6A70,"void ossl_quic_stream_map_cleanup(QUIC_STREAM_MAP *qsm)
","
 Any streams still in the map will be released as though
 ossl_quic_stream_map_release was called on them.
 ",openssl
EE95207F8A1427E3,"static int check_purpose_ocsp_helper(const X509_PURPOSE *xp, const X509 *x,
                                     int non_leaf)
","
 OCSP helper: this is *not* a full OCSP check. It just checks that each CA
 is valid. Additional checks must be made on the chain.
 ",openssl
B3CA49AE50AA5553,"void ossl_quic_txpim_free(QUIC_TXPIM *txpim)
","
 Frees the TXPIM. All QUIC_TXPIM_PKTs which have been handed out by the TXPIM
 must be released via a call to ossl_quic_txpim_pkt_release() before calling
 this function.
 ",openssl
B14FF577E75F4333,"int TS_RESP_CTX_add_md(TS_RESP_CTX *ctx, const EVP_MD *md)
","
 Adds a new acceptable message digest. Note that no message digests are
 accepted by default. The md argument is shared with the caller.
 ",openssl
AE5A8AC3C44BCAB7,"static ossl_inline int compute_growth(int target, int current)
","
 Calculate the array growth based on the target size.

 The growth factor is a rational number and is defined by a numerator
 and a denominator.  According to Andrew Koenig in his paper ""Why Are
 Vectors Efficient?"" from JOOP 11(5) 1998, this factor should be less
 than the golden ratio (1.618...).

 Considering only the Fibonacci ratios less than the golden ratio, the
 number of steps from the minimum allocation to integer overflow is:
      factor  decimal    growths
       3/2     1.5          51
       8/5     1.6          45
      21/13    1.615...     44

 All larger factors have the same number of growths.

 3/2 and 8/5 have nice power of two shifts, so seem like a good choice.
 ",openssl
EFA75CD487735403,"int ossl_qrl_enc_level_set_have_el(OSSL_QRL_ENC_LEVEL_SET *els,
                                  uint32_t enc_level)
","
 Returns 1 if we have key material for a given encryption level (that is, if
 we are in the PROVISIONED state), 0 if we do not yet have material (we are in
 the UNPROVISIONED state) and -1 if the EL is discarded (we are in the
 DISCARDED state).
 ",openssl
68294A4C6AA331E0,"void ossl_statem_set_renegotiate(SSL_CONNECTION *s)
","
 Set the state machine up ready for a renegotiation handshake
 ",openssl
7910A7A9D34B934F,"int SXNET_add_id_asc(SXNET **psx, const char *zone, const char *user, int userlen)
",Add an id given the zone as an ASCII number ,openssl
6EA04EB8AF1579A0,"OSSL_TIME ossl_quic_engine_get_time(QUIC_ENGINE *qeng)
",Gets the current time. ,openssl
88C2FB6CC13F3260,"int ossl_quic_gen_rand_conn_id(OSSL_LIB_CTX *libctx, size_t len,
                               QUIC_CONN_ID *cid)
","
 Generates a random CID of the given length. libctx may be NULL.
 Returns 1 on success or 0 on failure.
 ",openssl
E45BF6A232C49079,"static int setup_client_ctx(OSSL_CMP_CTX *ctx, ENGINE *engine)
","
 set up the client-side OSSL_CMP_CTX based on options from config file/CLI
 while parsing options and checking their consistency.
 Prints reason for error to bio_err.
 Returns 1 on success, 0 on error
 ",openssl
4FD107FA558F51A2,"void ossl_quic_srtm_free(QUIC_SRTM *srtm)
",Frees a SRTM instance. No-op if srtm is NULL. ,openssl
218D0EC0FABB76A1,"OSSL_PROPERTY_LIST **ossl_ctx_global_properties(OSSL_LIB_CTX *libctx,
                                                ossl_unused int loadconfig)
",Get the global properties associate with the specified library context ,openssl
BA863A3BCB7C141B,"OSSL_TIME ossl_ackm_get_pto_duration(OSSL_ACKM *ackm)
","
 Returns the PTO duration as currently calculated. This is a quantity of time.
 This duration is used in various parts of QUIC besides the ACKM.
 ",openssl
268C244B2DAF749A,"QUIC_RSTREAM *ossl_quic_rstream_new(QUIC_RXFC *rxfc,
                                    OSSL_STATM *statm, size_t rbuf_size)
","
 Create a new instance of QUIC_RSTREAM with pointers to the flow
 controller and statistics module. They can be NULL for unit testing.
 If they are non-NULL, the `rxfc` is called when receive stream data
 is read by application. `statm` is queried for current rtt.
 `rbuf_size` is the initial size of the ring buffer to be used
 when ossl_quic_rstream_move_to_rbuf() is called.
 ",openssl
DA30567D7A096837,"int RSA_up_ref(RSA *r)
","""up"" the RSA object's reference count ",openssl
F16AF07654F97FCA,"const char *OSSL_HTTP_adapt_proxy(const char *proxy, const char *no_proxy,
                                  const char *server, int use_ssl)
","Take default value from environment variable(s), respect no_proxy ",openssl
44DA538004568DB5,"static int bits2int(BIGNUM *out, int qlen_bits,
                    const unsigned char *in, size_t inlen)
","
 Convert a Bit String to an Integer (See RFC 6979 Section 2.3.2)

 Params:
     out The returned Integer as a BIGNUM
     qlen_bits The maximum size of the returned integer in bits. The returned
        Integer is shifted right if inlen is larger than qlen_bits..
     in, inlen The input Bit String (in bytes).
 Returns: 1 if successful, or  0 otherwise.
 ",openssl
E6935D22AC352B5A,"OSSL_QTX *ossl_qtx_new(const OSSL_QTX_ARGS *args)
",Instantiates a new QTX. ,openssl
719446CC9497E0DF,"int ossl_quic_lcidm_generate_initial(QUIC_LCIDM *lcidm,
                                     void *opaque,
                                     QUIC_CONN_ID *initial_lcid)
","
 Create the first LCID for a given opaque pointer. The generated LCID is
 written to *initial_lcid and associated with the given opaque pointer.

 After this function returns successfully, the caller can for example
 register the new LCID with a DEMUX.

 May not be called more than once for a given opaque pointer value.
 ",openssl
66E66FBDB4E847D3,"static int obj_new_nid_unlocked(int num)
","
 Requires that the ossl_obj_lock be held
 if TSAN_REQUIRES_LOCKING defined
 ",openssl
EBF660A72E74BE1C,"int ossl_quic_rxfc_init_standalone(QUIC_RXFC *rxfc,
                                   uint64_t initial_window_size,
                                   OSSL_TIME (*now)(void *arg),
                                   void *now_arg)
","
 Initialises an RX flow controller which is used by itself and not under a
 connection-level RX flow controller. This can be used for stream count
 enforcement as well as CRYPTO buffer enforcement.
 ",openssl
DBCCC2264AA08AAB,"void ossl_quic_tx_packetiser_set_ack_tx_cb(OSSL_QUIC_TX_PACKETISER *txp,
                                           void (*cb)(const OSSL_QUIC_FRAME_ACK *ack,
                                                      uint32_t pn_space,
                                                      void *arg),
                                           void *cb_arg)
","
 Sets a callback which is called whenever TXP sends an ACK frame. The callee
 must not modify the ACK frame data. Can be used to snoop on PNs being ACKed.
 ",openssl
4C9907D4F94F29B5,"void ossl_quic_channel_set_incoming_stream_auto_reject(QUIC_CHANNEL *ch,
                                                       int enable,
                                                       uint64_t aec)
","
 Configures incoming stream auto-reject. If enabled, incoming streams have
 both their sending and receiving parts automatically rejected using
 STOP_SENDING and STREAM_RESET frames. aec is the application error
 code to be used for those frames.
 ",openssl
41D90C0C118C1A88,"static ossl_inline int ssl_has_cert(const SSL_CONNECTION *s, int idx)
",Returns true if certificate and private key for 'idx' are present ,openssl
D24E1897A054FB1E,"static const SIGALG_LOOKUP *tls1_lookup_sigalg(const SSL_CONNECTION *s,
                                               uint16_t sigalg)
",Lookup TLS signature algorithm ,openssl
E255542D4F8240B0,"void ossl_quic_demux_set_default_handler(QUIC_DEMUX *demux,
                                         ossl_quic_demux_cb_fn *cb,
                                         void *cb_arg)
","
 Set the default packet handler. This is used for incoming packets which don't
 match a registered DCID. This is only needed for servers. If a default packet
 handler is not set, a packet which doesn't match a registered DCID is
 silently dropped. A default packet handler may be unset by passing NULL.

 The handler is responsible for ensuring that ossl_quic_demux_reinject_urxe or
 ossl_quic_demux_release_urxe is called on the passed packet at some point in
 the future, which may or may not be before the handler returns.
 ",openssl
290803D9285A97DF,"void ossl_sframe_list_destroy(SFRAME_LIST *fl)
","
 Destroys the stream frame list fl releasing any data
 still present inside it.
 ",openssl
C3F07A0B34E39E13,"static int get_compressed_certificate_alg(SSL_CONNECTION *sc)
","
 Used to determine if we should send a CompressedCertificate message

 Returns the algorithm to use, TLSEXT_comp_cert_none means no compression
 ",openssl
F26B5D118AC8365C,"OSSL_STORE_SEARCH *OSSL_STORE_SEARCH_by_name(X509_NAME *name)
","Search term constructors 

The input is considered to be owned by the caller, and must therefore
remain present throughout the lifetime of the returned OSSL_STORE_SEARCH",openssl
9C5181DDD3BA18D0,"int ossl_quic_txfc_init(QUIC_TXFC *txfc, QUIC_TXFC *conn_txfc)
","
 Initialises a TX flow controller. conn_txfc should be non-NULL and point to
 the connection-level flow controller if the TXFC is for stream-level flow
 control, and NULL otherwise.
 ",openssl
ACC2F8D9A0A4B244,"void X509_VERIFY_PARAM_move_peername(X509_VERIFY_PARAM *to,
                                     X509_VERIFY_PARAM *from)
","
 Move peername from one param structure to another, freeing any name present
 at the target.  If the source is a NULL parameter structure, free and zero
 the target peername.
 ",openssl
8DB27DCC9D8540B9,"redisContext *redisConnectWrapper(const char *ip, int port, const struct timeval tv) ",This is a wrapper to call redisConnect or redisConnectWithTimeout. ,redis
9E709D637B4875DE,static int dictCheckRehashingCompleted(dict *d) ,This checks if we already rehashed the whole table and if more rehashing is required ,redis
B7AED9E236EBEC25,"size_t rioWriteBulkDouble(rio *r, double d) ","Write a double value in the format: ""$<count>\r\n<payload>\r\n"" ",redis
917B2B41B044128F,"sds fillPercentileDistributionLatencies(sds info, const char* histogram_name, struct hdr_histogram* histogram) ",Fill percentile distribution of latencies. ,redis
63BD3C16404EFF44,void luaSetErrorMetatable(lua_State *lua) ,"Set a special metatable on the table on the top of the stack.
The metatable will raise an error if the user tries to fetch
an un-existing value.

The function assumes the Lua stack have a least enough
space to push 2 element, its up to the caller to verify
this before calling this function. ",redis
91E59A8BE2E5834C,"sds luaGetStringSds(lua_State *lua, int index) ","Return sds of the string value located on stack at the given index.
Return NULL if the value is not a string. ",redis
C3CB2474A9CFDEB8,"static void luaCreateArray(lua_State *lua, robj **elev, int elec) ","Set an array of Redis String Objects as a Lua array (table) stored into a
global variable. ",redis
BFD3412F5AA28A38,"void updateCommandLatencyHistogram(struct hdr_histogram **latency_histogram, int64_t duration_hist)","This function is called in order to update the total command histogram duration.
The latency unit is nano-seconds.
If needed it will allocate the histogram memory and trim the duration to the upper/lower tracking limits",redis
8C34082F9371FB54,"static void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) ","---------------------------------------------------------------------------
Lua engine initialization and reset.
------------------------------------------------------------------------- ",redis
49B52B607F6CE286,"void luaSaveOnRegistry(lua_State* lua, const char* name, void* ptr) ","
 Save the give pointer on Lua registry, used to save the Lua context and
 function context so we can retrieve them from lua_State.
 ",redis
EE3BEF081FCA3E6A,void scriptingRelease(int async) ,"Release resources related to Lua scripting.
This function is used in order to reset the scripting environment. ",redis
79DA9CB3C0C6D261,"static void luaEngineCall(scriptRunCtx *run_ctx,
                          void *engine_ctx,
                          void *compiled_function,
                          robj **keys,
                          size_t nkeys,
                          robj **args,
                          size_t nargs)
","
 Invole the give function with the given keys and args
 ",redis
145F9153FF2001AA,void ThreadsManager_init(void) ,Register the process to THREADS_SIGNAL ,redis
0CBA565430D94C57,static unsigned long evictionTimeLimitUs(void) ,Algorithm for converting tenacity (0-100) to a time limit.  ,redis
340C2A92AAB661BC,"static int matchToken(char **nextword, cliCommandArg *arg) ",Tries to match the next word of the input against a token literal. ,redis
D1F436E96A24FDB2,void cliRestoreTTY(void) ,Restore terminal if we've changed it. ,redis
F82D2410AAC6480A,static void cliPressAnyKeyTTY(void) ,"Put the terminal in ""press any key"" mode ",redis
9B049E7250A7BADF,unsigned long bioPendingJobsOfType(int type) ,Return the number of pending jobs of the specified type. ,redis
BADD1866448F8D09,"int reclaimFilePageCache(int fd, size_t offset, size_t length) ",free OS pages backed by file ,redis
5A7030DACAB7E146,"static inline int formatAddr(char *buf, size_t buf_len, char *ip, int port) ","Format an IP,port pair into something easy to parse. If IP is IPv6
(matches for "":""), the ip is surrounded by []. IP and port are just
separated by colons. This the standard to display addresses within Redis. ",redis
E2463C73985C1A58,"void genClientAddrString(client *client, char *addr,
                         size_t addr_len, int remote) ","A Redis ""Address String"" is a colon separated ip:port pair.
For IPv4 it's in the form x.y.z.k:port, example: ""127.0.0.1:1234"".
For IPv6 addresses we use [] around the IP part, like in ""[::1]:1234"".
For Unix sockets we use path:0, like in ""/tmp/redis:0"".

An Address String always fits inside a buffer of NET_ADDR_STR_LEN bytes,
including the null term.

On failure the function still populates 'addr' with the ""?:0"" string in case
you want to relax error checking or need to display something anyway (see
anetFdToString implementation for more info). ",redis
1F81C060E269517F,int clusterLockConfig(char *filename) ,"Lock the cluster config using flock(), and retain the file descriptor used to
acquire the lock so that the file will be locked as long as the process is up.

This works because we always update nodes.conf with a new version
in-place, reopening the file, and writing to it in place (later adjusting
the length with ftruncate()).

On success C_OK is returned, otherwise an error is logged and
the function returns C_ERR to signal a lock was not acquired. ",redis
2EFBDA204288D7E9,"int string2d(const char *s, size_t slen, double *dp) ","Convert a string into a double. Returns 1 if the string could be parsed
into a (non-overflowing) double, 0 otherwise. The value will be set to
the parsed value when appropriate.

Note that this function demands that the string strictly represents
a double: no spaces or other characters before or after the string
representing the number are accepted. ",redis
DAFD43712C86427A,int zslRandomLevel(void) ,"Returns a random level for the new skiplist node we are going to create.
The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL
(both inclusive), with a powerlaw-alike distribution where higher
levels are less likely to be returned. ",redis
56885AFA07B9F858,"REDIS_NO_SANITIZE(""bounds"")
size_t _addReplyToBuffer(client *c, const char *s, size_t len) ","Attempts to add the reply to the static buffer in the client struct.
Returns the length of data that is added to the reply buffer.

Sanitizer suppression: client->buf_usable_size determined by
zmalloc_usable_size() call. Writing beyond client->buf boundaries confuses
sanitizer and generates a false positive out-of-bounds error ",redis
F363CFD77CB13669,unsigned long kvstoreBuckets(kvstore *kvs) ,"This method provides the cumulative sum of all the dictionary buckets
across dictionaries in a database. ",redis
C9AD0CB2169AB708,long getTimeZone(void) ,"
 Gets the proper timezone in a more portable fashion
 i.e timezone variables are linux specific.
 ",redis
2F6791789BCEDFFA,"void dictRehashingInfo(dict *d, unsigned long long *from_size, unsigned long long *to_size) ","Provides the old and new ht size for a given dictionary during rehashing. This method
should only be invoked during initialization/rehashing. ",redis
252B6857A9882E34,size_t dictMemUsage(const dict *d) ,"Returns the memory usage in bytes of the dict, excluding the size of the keys
and values. ",redis
744001044C7F2F92,"static void* getAndSetMcontextEip(ucontext_t *uc, void *eip) ",Returns the current eip and set it to the given new value (if its not NULL) ,redis
1888551133AB0C37,char *getObjectTypeName(robj *o) ,"The string name for an object's type as listed above
Native types are checked against the OBJ_STRING, OBJ_LIST, OBJ_* defines,
and Module types have their registered name returned. ",redis
3EABC43DB66CDE6D,"void totalNumberOfBlockingKeys(unsigned long *blocking_keys, unsigned long *bloking_keys_on_nokey) ","sets blocking_keys to the total number of keys which has at least one client blocked on them
sets blocking_keys_on_nokey to the total number of keys which has at least one client
blocked on them to be written or deleted ",redis
53226269E2E8F8F7,int cmdHasPushAsReply(struct redisCommand *cmd) ,"The subscribe / unsubscribe command family has a push as a reply,
or in other words, it responds with a push (or several of them
depending on how many arguments it got), and has no reply. ",redis
83A7FD4CE5361D05,static connection *connCreateSocket(void) ,"When a connection is created we must know its type already, but the
underlying socket may or may not exist:

- For accepted connections, it exists as we do not model the listen/accept
  part; So caller calls connCreateSocket() followed by connAccept().
- For outgoing connections, the socket is created by the connection module
  itself; So caller calls connCreateSocket() followed by connConnect(),
  which registers a connect callback that fires on connected/error state
  (and after any transport level handshake was done).

NOTE: An earlier version relied on connections being part of other structs
and not independently allocated. This could lead to further optimizations
like using container_of(), etc.  However it was discontinued in favor of
this approach for these reasons:

1. In some cases conns are created/handled outside the context of the
containing struct, in which case it gets a bit awkward to copy them.
2. Future implementations may wish to allocate arbitrary data for the
connection.
3. The container_of() approach is anyway risky because connections may
be embedded in different structs, not just client.",redis
C09BE7C7570CD694,"void trackInstantaneousMetric(int metric, long long current_value, long long current_base, long long factor) ","Add a sample to the instantaneous metric. This function computes the quotient
of the increment of value and base, which is useful to record operation count
per second, or the average time consumption of an operation.

current_value - The dividend
current_base - The divisor",redis
F586455FB012D15B,monotonic_clock_type monotonicGetType(void) ,Return the type of monotonic clock being used. ,redis
FA12006B2296E11D,unsigned long functionsMemoryOverhead(void) ,Return memory overhead of all the engines combine ,redis
C15524E7A8A6A858,"static inline void *ztrycalloc_usable_internal(size_t size, size_t *usable) ","Try allocating memory and zero it, and return NULL if failed.
'*usable' is set to the usable size if non NULL. ",redis
1D4A8BB4C20DCE3F,"static unsigned long long cumulativeKeyCountRead(kvstore *kvs, int didx) ","Returns total (cumulative) number of keys up until given dict-index (inclusive).
Time complexity is O(log(kvs->num_dicts)). ",redis
53097E4BA66791C4,int kvstoreGetFairRandomDictIndex(kvstore *kvs) ,"Returns fair random dict index, probability of each dict being returned is proportional to the number of elements that dictionary holds.
This function guarantees that it returns a dict-index of a non-empty dict, unless the entire kvstore is empty.
Time complexity of this function is O(log(kvs->num_dicts)). ",redis
4301A1FCF0E2E43E,"int kvstoreGetNextNonEmptyDictIndex(kvstore *kvs, int didx) ","Returns next non-empty dict index strictly after given one, or -1 if provided didx is the last one. ",redis
BB017E58605FED92,dict *kvstoreIteratorNextDict(kvstoreIterator *kvs_it) ,"Returns next dictionary from the iterator, or NULL if iteration is complete. ",redis
8AF415B62FB4C87E,"int dictTryExpand(dict *d, unsigned long size) ",return DICT_ERR if expand failed due to memory allocation failure ,redis
8146BBD51D425734,"int anetKeepAlive(char *err, int fd, int interval)
","Enable TCP keep-alive mechanism to detect dead peers,
TCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT will be set accordingly. ",redis
0662CB892CF59881,"int raxFind(rax *rax, unsigned char *s, size_t len, void **value) ","Find a key in the rax: return 1 if the item is found, 0 otherwise.
If there is an item and 'value' is passed in a non-NULL pointer,
the value associated with the item is set at that address. ",redis
8BE29A91E9BFE43F,static void sigKillChildHandler(int sig) ,"This is the signal handler for children process. It is currently useful
in order to track the SIGUSR1, that we send to a child in order to terminate
it in a clean way, without the parent detecting an error and stop
accepting writes because of a write error condition. ",redis
4E9473BD7ADA756A,void ACLInitCommandCategories(void) ,"Initializes ACLCommandCategories with default ACL categories and allocates space for 
new ACL categories.",redis
8A932B490A6BCD6E,"int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) ","Helper function to extract keys from the SORT RO command.

SORT <sort-key>

The second argument of SORT is always a key, however an arbitrary number of
keys may be accessed while doing the sort (the BY and GET args), so the
key-spec declares incomplete keys which is why we have to provide a concrete
implementation to fetch the keys.

This command declares incomplete keys, so the flags are correctly set for this function ",redis
BA9F49D506CE32B7,"void deriveAnnouncedPorts(int *announced_tcp_port, int *announced_tls_port,
                          int *announced_cport) ",Derives our ports to be announced in the cluster bus. ,redis
D96D35EDDAADBECC,robj *createStringObjectFromLongLongForValue(long long value) ,"The function avoids returning a shared integer when LFU/LRU info
are needed, that is, when the object is used as a value in the key
space(for instance when the INCR command is used), and Redis is
configured to evict based on LFU/LRU, so we want LFU/LRU values
specific for each key. ",redis
8B7D3882CF9CBFEC,unsigned int LRU_CLOCK(void) ,"This function is used to obtain the current LRU clock.
If the current resolution is lower than the frequency we refresh the
LRU clock (as it should be in production servers) we return the
precomputed value, otherwise we need to resort to a system call. ",redis
CA200194ACEB9F7D,"void zsetTypeMaybeConvert(robj *zobj, size_t size_hint) ","Check if the existing zset should be converted to another encoding based off the
the size hint. ",redis
60BC84F411EBEAB3,"int kvstoreExpand(kvstore *kvs, uint64_t newsize, int try_expand, kvstoreExpandShouldSkipDictIndex *skip_cb) ","
 This functions increases size of kvstore to match desired number.
 It resizes all individual dictionaries, unless skip_cb indicates otherwise.

 Based on the parameter `try_expand`, appropriate dict expand API is invoked.
 if try_expand is set to 1, `dictTryExpand` is used else `dictExpand`.
 The return code is either `DICT_OK`/`DICT_ERR` for both the API(s).
 `DICT_OK` response is for successful expansion. However ,`DICT_ERR` response signifies failure in allocation in
 `dictTryExpand` call and in case of `dictExpand` call it signifies no expansion was performed.
 ",redis
6B610D8B9F68DAE1,"int dictResizeAllowed(size_t moreMem, double usedRatio) ","Return 1 if currently we allow dict to expand. Dict may allocate huge
memory to contain hash buckets when dict expands, that may lead redis
rejects user's requests or evicts some keys, we can stop dict to expand
provisionally if used memory will be over maxmemory after dict expands,
but to guarantee the performance of redis, we still allow dict to expand
if dict load factor exceeds HASHTABLE_MAX_LOAD_FACTOR. ",redis
8A27BFF462650406,"static void dbAddInternal(redisDb *db, robj *key, robj *val, int update_if_existing) ","Add the key to the DB. It's up to the caller to increment the reference
counter of the value if needed.

If the update_if_existing argument is false, the program is aborted
if the key already exists, otherwise, it can fall back to dbOverwrite. ",redis
051CCB38BF73BF65,"int dbAddRDBLoad(redisDb *db, sds key, robj *val) ","This is a special version of dbAdd() that is used only when loading
keys from the RDB file: the key is passed as an SDS string that is
retained by the function (and not freed by the caller).

Moreover this function will not abort if the key is already busy, to
give more control to the caller, nor will signal the key as ready
since it is not useful in this context.

The function returns 1 if the key was added to the database, taking
ownership of the SDS string, otherwise 0 is returned, and is up to the
caller to free the SDS string. ",redis
3676B55A0684B8C4,static void kvstoreDictRehashingStarted(dict *d) ,"Adds dictionary to the rehashing list, which allows us
to quickly find rehash targets during incremental rehashing.

If there are multiple dicts, updates the bucket count for the given dictionary
in a DB, bucket count incremented with the new ht size during the rehashing phase.
If there's one dict, bucket count can be retrieved directly from single dict bucket. ",redis
235340703317EEF1,void kvstoreIteratorRelease(kvstoreIterator *kvs_it) ,Free the kvs_it returned by kvstoreIteratorInit. ,redis
B9770C032ED2D79F,void scanDatabaseForReadyKeys(redisDb *db) ,"Helper function for dbSwapDatabases(): scans the list of keys that have
one or more blocked clients for B[LR]POP or other blocking commands
and signal the keys as ready if they are of the right type. See the comment
where the function is used for more info. ",redis
D7B3A40224F9F596,void unblockClientOnTimeout(client *c) ,"Unblock a client which is currently Blocked on and provided a timeout.
The implementation will first reply to the blocked client with null response
or, in case of module blocked client the timeout callback will be used.
In this case since we might have a command pending
we want to remove the pending flag to indicate we already responded to the
command with timeout reply. ",redis
1D2EBFAEB02EB387,"void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration) ","Push a new entry into the slow log.
This function will make sure to trim the slow log accordingly to the
configured max length. ",redis
34E0B83C2E59A0E6,void updateClientMemoryUsage(client *c) ,"
 This method updates the client memory usage and update the
 server stats for client type.

 This method is called from the clientsCron to have updated
 stats for non CLIENT_TYPE_NORMAL/PUBSUB clients to accurately
 provide information around clients memory usage.

 It is also used in updateClientMemUsageAndBucket to have latest
 client memory usage information to place it into appropriate client memory
 usage bucket.
 ",redis
6F0C31DFFEC181FB,"streamCG *streamLookupCG(stream *s, sds groupname) ","Lookup the consumer group in the specified stream and returns its
pointer, otherwise if there is no such group, NULL is returned. ",redis
561120EE41B27B2E,"int dictRehashMicroseconds(dict *d, uint64_t us) ","Rehash in us+""delta"" microseconds. The value of ""delta"" is larger
than 0, and is smaller than 1000 in most cases. The exact upper bound
depends on the running time of dictRehash(d,100).",redis
1E86D002109F35F0,"streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read) ","Create a new consumer group in the context of the stream 's', having the
specified name, last server ID and reads counter. If a consumer group with
the same name already exists NULL is returned, otherwise the pointer to the
consumer group is returned. ",redis
C1BC3BEC28C03F06,ErrorOr<StringRef> SampleProfileReaderBinary::readString() ,"Read a string from the profile.

If an error occurs during decoding, a diagnostic message is emitted and
EC is set.

\returns the read value.",llvm
A7AB81C8E4DCDC67,  void grow(size_t N) ,Ensure there are at least N more positions in the buffer.,llvm
BD2DC0F2F8DD4DEC,"void OrcX86_64_Base::writeTrampolines(char *TrampolineBlockWorkingMem,
                                      ExecutorAddr TrampolineBlockTargetAddress,
                                      ExecutorAddr ResolverAddr,
                                      unsigned NumTrampolines) ","Write the requested number of trampolines into the given memory,
which must be big enough to hold 1 pointer, plus NumTrampolines
trampolines.",llvm
04C8813A1EE4450F,"ErrorOr<std::unique_ptr<SampleProfileReader>>
SampleProfileReader::create(const std::string Filename, LLVMContext &C,
                            vfs::FileSystem &FS, FSDiscriminatorPass P,
                            const std::string RemapFilename) ","Create a sample profile reader appropriate to the file format.
Create a remapper underlying if RemapFilename is not empty.
Parameter P specifies the FSDiscriminatorPass.",llvm
A19320F747B60D76,"std::error_code llvm::EmitImportsFiles(
    StringRef ModulePath, StringRef OutputFilename,
    const std::map<std::string, GVSummaryMapTy> &ModuleToSummariesForIndex) ",Emit into \p OutputFilename the files module \p ModulePath will import from.,llvm
10B1B6E197369BB6,ThreadPool::~ThreadPool() ,Blocking destructor: the pool will wait for all the threads to complete.,llvm
455EF5EE60B536EC,std::chrono::milliseconds getDefaultDebuginfodTimeout() ,"Finds a default timeout for debuginfod HTTP requests. Checks
DEBUGINFOD_TIMEOUT environment variable, default is 90 seconds (90000 ms).",llvm
9F07BA675598F8EA,  void initializePackExpansion(OutputBuffer &OB) const ,"Setup OutputBuffer for a pack expansion, unless we're already expanding
one.",llvm
5F93B753CE8A58FE,"std::unique_ptr<MIRParser> llvm::createMIRParserFromFile(
    StringRef Filename, SMDiagnostic &Error, LLVMContext &Context,
    std::function<void(Function &)> ProcessIRFunction) ","This function is the main interface to the MIR serialization format parser.

It reads in a MIR file and returns a MIR parser that can parse the embedded
LLVM IR module and initialize the machine functions by parsing the machine
function's state.

\param Filename - The name of the file to parse.
\param Error - Error result info.
\param Context - Context which will be used for the parsed LLVM IR module.
\param ProcessIRFunction - function to run on every IR function or stub
loaded from the MIR file.",llvm
6A6BE28E5DA17399,void llvm::install_out_of_memory_new_handler() ,"Installs new handler that causes crash on allocation failure. It is called by
InitLLVM.",llvm
E9A0485F1DBF0175,unsigned SourceMgr::SrcBuffer::getLineNumber(const char *Ptr) const ,"Look up a given \p Ptr in the buffer, determining which line it came
from.",llvm
1BB1EAA93F31CA22,static const NEONLdStTableEntry *LookupNEONLdSt(unsigned Opcode) ,"LookupNEONLdSt - Search the NEONLdStTable for information about a NEON
load or store pseudo instruction.",llvm
DCC42EFE21BAC90C,  BasicBlockBits getBasicBlockBits() const ,Safely reinterpret the subclass data bits to a more useful form.,llvm
65864C55741B0B7A,"static bool combine(const CodeGenSubRegIndex *Idx,
                    SmallVectorImpl<CodeGenSubRegIndex *> &Vec) ","Try to combine Idx's compose map into Vec if it is compatible.
Return false if it's not possible.",llvm
2203A9ADE06F7F30,static TreePatternNodePtr PromoteXForms(TreePatternNodePtr N) ,Promote xform function to be an explicit node wherever set.,llvm
5EE96E0B69B072FF,std::vector<ValueTypeByHwMode> CodeGenTarget::getRegisterVTs(Record *R) const ,"getRegisterVTs - Find the union of all possible SimpleValueTypes for the
specified physical register.",llvm
D291EF0201C0B2FA,Matcher *Matcher::unlinkNode(Matcher *Other) ,"unlinkNode - Unlink the specified node from this chain.  If Other ==
this, we unlink the next pointer and return it.  Otherwise we unlink
Other from the list and return this.",llvm
135AB6DB6E67CB5A,"bool VPCanonicalIVPHIRecipe::isCanonical(
    InductionDescriptor::InductionKind Kind, VPValue *Start,
    VPValue *Step) const ","Check if the induction described by \p Kind, /p Start and \p Step is
canonical, i.e.  has the same start and step (of 1) as the canonical IV.",llvm
9D32EA254C7044EC,"CCAssignFn *
AArch64TargetLowering::CCAssignFnForReturn(CallingConv::ID CC) const ",Selects the correct CCAssignFn for a given CallingConvention value.,llvm
4735CDFEDB70C30E,  void initInSeq(const TargetRegisterInfo &TRI) ,Populate InSeq with liveness information.,llvm
47249762535B6FF1,"template <class Tr>
typename RegionBase<Tr>::BlockT *RegionBase<Tr>::getEnteringBlock() const ","Return the first block of this region's single entry edge,
       if existing.

@return The BasicBlock starting this region's single entry edge,
        else NULL.",llvm
57A29FD53DCA2606,bool SMEAttrs::requiresSMChange(const SMEAttrs &Callee) const ,"\return true if a call from Caller -> Callee requires a change in
streaming mode.",llvm
081EA200BE41D4AA,void TargetPassConfig::addCodeGenPrepare() ,"Add pass to prepare the LLVM IR for code generation. This should be done
before exception handling preparation passes.",llvm
41446EA1547D3DBE,"  virtual bool isTruncateFree(SDValue Val, EVT VT2) const ",Return true if truncating the specific node Val to type VT2 is free.,llvm
DCAD5D2D52DC76DF,"void AMDGPUInstructionSelector::splitIllegalMUBUFOffset(
  MachineIRBuilder &B, Register &SOffset, int64_t &ImmOffset) const ","Split an immediate offset \p ImmOffset depending on whether it fits in the
immediate field. Modifies \p ImmOffset and sets \p SOffset to the variable
component.",llvm
3A3B56C79D8D1481,"VPValue *vputils::getOrCreateVPValueForSCEVExpr(VPlan &Plan, const SCEV *Expr,
                                                ScalarEvolution &SE) ","Get or create a VPValue that corresponds to the expansion of \p Expr. If \p
Expr is a SCEVConstant or SCEVUnknown, return a VPValue wrapping the live-in
value. Otherwise return a VPExpandSCEVRecipe to expand \p Expr. If \p Plan's
pre-header already contains a recipe expanding \p Expr, return it. If not,
create a new one.",llvm
CB2779E506111B64,"SlotIndex LiveRangeEdit::rematerializeAt(MachineBasicBlock &MBB,
                                         MachineBasicBlock::iterator MI,
                                         Register DestReg, const Remat &RM,
                                         const TargetRegisterInfo &tri,
                                         bool Late, unsigned SubIdx,
                                         MachineInstr *ReplaceIndexMI) ","rematerializeAt - Rematerialize RM.ParentVNI into DestReg by inserting an
instruction into MBB before MI. The new instruction is mapped, but
liveness is not updated. If ReplaceIndexMI is not null it will be replaced
by new MI in the index map.
Return the SlotIndex of the new instruction.",llvm
8E118F1D6EE743FE,"bool SCEVExpander::isExpandedAddRecExprPHI(PHINode *PN, Instruction *IncV,
                                           const Loop *L) ","Determine if this cyclic phi is in a form that would have been generated by
LSR. We don't care if the phi was actually expanded in this pass, as long
as it is in a low-cost form, for example, no implied multiplication. This
should match any patterns generated by getAddRecExprPHILiterally and
expandAddtoGEP.",llvm
1E5C45F37A76125F,void VPlanTransforms::createAndOptimizeReplicateRegions(VPlan &Plan) ,"Wrap predicated VPReplicateRecipes with a mask operand in an if-then
region block and remove the mask operand. Optimize the created regions by
iteratively sinking scalar operands into the region, followed by merging
regions until no improvements are remaining.",llvm
21896FC1EC29AD52,bool TargetLibraryInfoImpl::isFunctionVectorizable(StringRef funcName) const ,"Return true if the function F has a vector equivalent with any
vectorization factor.",llvm
C6A84ACD8DB87546,  void add(const SeqT &Seq) ,"add - Add a sequence to the table.
This must be called before layout().",llvm
347889ACE5A83B22,"static void FindDepVars(TreePatternNode &N, MultipleUseVarSet &DepVars) ",Find dependent variables within child patterns,llvm
022B4872CF6D47FE,  bool isContradictory(const Matcher *Other) const ,"isContradictory - Return true of these two matchers could never match on
the same node.",llvm
5FF38911DE3E69F9,  bool isFlatOperandNotEmitted(unsigned FlatOpNo) const ,"isFlatOperandNotEmitted - Return true if the specified flat operand #
should not be emitted with the code emitter.",llvm
61FDF85A255190F3,"  virtual Register isLoadFromStackSlot(const MachineInstr &MI,
                                       int &FrameIndex,
                                       unsigned &MemBytes) const ","Optional extension of isLoadFromStackSlot that returns the number of
bytes loaded from the stack. This must be implemented if a backend
supports partial stack slot spills/loads to further disambiguate
what the load does.",llvm
F1AB034FF9F54521,"const X86FoldTableEntry *llvm::lookupBroadcastFoldTable(unsigned RegOp,
                                                        unsigned OpNum) ","Look up the broadcast folding table entry for folding a broadcast with
operand OpNum.",llvm
A9F73F1640F117BA,"std::optional<int64_t>
DwarfLinkerForBinary::AddressManager::hasValidRelocationAt(
    const std::vector<ValidReloc> &AllRelocs, uint64_t StartOffset,
    uint64_t EndOffset, bool Verbose) ","Checks that there is a relocation in the \p Relocs array against a
debug map entry between \p StartOffset and \p NextOffset.
Print debug output if \p Verbose is set.

\returns relocation value if relocation exist, otherwise std::nullopt.",llvm
F4FABCF2EFB953C6,"  void addVarLoc(VarLocInsertPt Before, DebugVariable Var, DIExpression *Expr,
                 DebugLoc DL, RawLocationWrapper R) ",Add a def to the wedge of defs just before /p Before.,llvm
C9181FD72A40273A,Expected<std::string> getCachedOrDownloadDebuginfo(BuildIDRef ID) ,"Fetches a debug binary by searching the default local cache directory and
server URLs.",llvm
DB9278CCBDD4AA03,  bool insert(const value_type &X) ,"Insert a new element into the SetVector.
\returns true if the element was inserted into the SetVector.",llvm
DC59B5FC4D1431C9,static void processDbgDeclares(FunctionLoweringInfo &FuncInfo) ,"Collect llvm.dbg.declare information. This is done after argument lowering
in case the declarations refer to arguments.",llvm
58EA62325D0C48FF,"void DebugInfoFinder::processInstruction(const Module &M,
                                         const Instruction &I) ",Process a single instruction and collect debug info anchors.,llvm
56E03C653BFF681D,"bool isInlinableLiteralV216(uint32_t Literal, uint8_t OpType) ",Whether the given literal can be inlined for a V_PK_* instruction.,llvm
6FEDAEEA24DD55B0,"Value *llvm::createAnyOfOp(IRBuilderBase &Builder, Value *StartVal,
                           RecurKind RK, Value *Left, Value *Right) ","See RecurrenceDescriptor::isAnyOfPattern for a description of the pattern we
are trying to match. In this pattern, we are only ever selecting between two
values: 1) an initial start value \p StartVal of the reduction PHI, and 2) a
loop invariant value. If any of lane value in \p Left, \p Right is not equal
to \p StartVal, select the loop invariant value. This is done by selecting
\p Right iff \p Left is equal to \p StartVal.",llvm
2154C620E839CDEB,"Constant *llvm::ConstantFoldLoadFromUniformValue(Constant *C, Type *Ty) ","If C is a uniform value where all bits are the same (either all zero, all
ones, all undef or all poison), return the corresponding uniform value in
the new type. If the value is not uniform or the result cannot be
represented, return null.",llvm
F90B550650B98F0A,bool CombinerHelper::tryCombineConcatVectors(MachineInstr &MI) ,"If \p MI is G_CONCAT_VECTORS, try to combine it.
Returns true if MI changed.
Right now, we support:
- concat_vector(undef, undef) => undef
- concat_vector(build_vector(A, B), build_vector(C, D)) =>
  build_vector(A, B, C, D)

\pre MI.getOpcode() == G_CONCAT_VECTORS.",llvm
70EEF13BFD6CD7B9,"  CodeGenSubRegIndex *addComposite(CodeGenSubRegIndex *A,
                                   CodeGenSubRegIndex *B) ","Add a composite subreg index: this+A = B.
Return a conflicting composite, or NULL",llvm
8FD16A68609F8B70,"std::pair<Value *, FPClassTest> llvm::fcmpToClassTest(FCmpInst::Predicate Pred,
                                                      const Function &F,
                                                      Value *LHS, Value *RHS,
                                                      bool LookThroughSrc) ","Returns a pair of values, which if passed to llvm.is.fpclass, returns the
same result as an fcmp with the given operands.

If \p LookThroughSrc is true, consider the input value when computing the
mask.

If \p LookThroughSrc is false, ignore the source value (i.e. the first pair
element will always be LHS.",llvm
4AAC00F9DBAB2703,void CodeGenRegBank::addToMaps(CodeGenRegisterClass *RC) ,Add RC to *2RC maps.,llvm
C769B65650756DEB,"static Register getMaxPushPopReg(const MachineFunction &MF,
                                 const std::vector<CalleeSavedInfo> &CSI) ",Get the max reg of Push/Pop for restoring callee saved registers.,llvm
292D96CBB32F5AF6,  unsigned newRegUnit(unsigned Weight) ,"Create a new non-native register unit that can be adopted by a register
to increase its pressure. Note that NumNativeRegUnits is not increased.",llvm
5FA5D3F4E05F7A0B,"  unsigned newRegUnit(CodeGenRegister *R0, CodeGenRegister *R1 = nullptr) ","Create a native register unit that is associated with one or two root
registers.",llvm
7A1498112E0F97DE,  unsigned getTopoSig() const ,"Get the topological signature of this register. This is a small integer
less than RegBank.getNumTopoSigs(). Registers with the same TopoSig have
identical sub-register structure. That is, they support the same set of
sub-register indices mapping to the same kind of sub-registers
(TopoSig-wise).",llvm
FD5686A3D786BAAE,CodeGenSubRegIndex *CodeGenRegBank::getSubRegIdx(Record *Def) ,"Find a SubRegIndex from its Record def or add to the list if it does
not exist there yet.",llvm
2D830BDA333FFC11,"void VPlanVerifier::verifyHierarchicalCFG(
    const VPRegionBlock *TopRegion) const ","Verify the invariants of the H-CFG starting from \p TopRegion. The
verification process comprises the following steps:
1. Region/Block verification: Check the Region/Block verification
invariants for every region in the H-CFG.",llvm
3241D0D94F5756B0,"LegalizerHelper::LegalizeResult
llvm::createLibcall(MachineIRBuilder &MIRBuilder, RTLIB::Libcall Libcall,
                    const CallLowering::ArgInfo &Result,
                    ArrayRef<CallLowering::ArgInfo> Args,
                    LostDebugLocObserver &LocObserver, MachineInstr *MI) ",Helper function that creates the given libcall.,llvm
6E2C5D1F01DE0934,"static unsigned getFixedObjectSize(const MachineFunction &MF,
                                   const AArch64FunctionInfo *AFI, bool IsWin64,
                                   bool IsFunclet) ","Returns the size of the fixed object area (allocated next to sp on entry)
On Win64 this may include a var args area and an UnwindHelp object for EH.",llvm
0B22468A30F51D0C,"MachineInstrBuilder
SIInstrInfo::getAddNoCarry(MachineBasicBlock &MBB,
                           MachineBasicBlock::iterator I,
                           const DebugLoc &DL,
                           Register DestReg) const ","Return a partially built integer add instruction without carry.
Caller must add source operands.
For pre-GFX9 it will generate unused carry destination operand.
TODO: After GFX9 it should return a no-carry operation.",llvm
5812479803CFD38A,uint64_t InstrProfSymtab::getFunctionHashFromAddress(uint64_t Address) ,"Return a function's hash, or 0, if the function isn't in this SymTab.",llvm
AA232096EAC1EC91,"const CodeGenIntrinsic *
TreePatternNode::getIntrinsicInfo(const CodeGenDAGPatterns &CDP) const ","getIntrinsicInfo - If this node corresponds to an intrinsic, return the
CodeGenIntrinsic information for it, otherwise return a null pointer.",llvm
7D36128668CA20A7,"SDNodeInfo::SDNodeInfo(Record *R, const CodeGenHwModes &CGH) : Def(R) ",Parse the specified record.,llvm
4C1DC2D4407A506B,CodeGenRegisterClass *CodeGenRegBank::getRegClass(const Record *Def) const ,Find a register class from its def.,llvm
6EF0AC47AE4C4498,"static void getInstructionsInTree(TreePatternNode &Tree,
                                  SmallVectorImpl<Record *> &Instrs) ",Get all the instructions in a tree.,llvm
B5EB2DF18B98E871,"static void printBitVectorAsHex(raw_ostream &OS, const BitVector &Bits,
                                unsigned Width) ","Print a BitVector as a sequence of hex numbers using a little-endian mapping.
Width is the number of bits per hex number.",llvm
08DD857AED455A3B,"CodeGenTarget::CodeGenTarget(RecordKeeper &records)
    : Records(records), CGH(records) ",getTarget - Return the current instance of the Target class.,llvm
0F0AC8651F1F799F,"static bool checkOperandClass(CGIOperandList::OperandInfo &OI, Record *Leaf) ","Check the class of a pattern leaf node against the instruction operand it
represents.",llvm
F79A96D3CF50C978,Record *TreePredicateFn::getMemoryVT() const ,"If non-null, indicates that this predicate is a predefined memory VT
predicate for a load/store and returns the ValueType record for the memory
VT.",llvm
